---
title: 第一章
---

## UDP

首先 UDP 协议是面向无连接的，也就是说不需要在正式传递数据之前进行三次握手建立连接。然后 UDP 协议只是数据报文的搬运工，不保证有序且不丢失的传递到对端，并且 UDP 协议也没有任何控制流量的算法，总的来说 UDP 相较于 TCP 更加的轻便。

-   网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。
-   因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的。
-   UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。

#### 适合使用的场景（用户肯定关注的是最新的画面，而不是老旧的画面）

-   直播
-   王者荣耀
    TCP 会严格控制传输的正确性，一旦有某一个数据对端没有收到，就会停止下来直到对端收到这个数据。这种问题在网络条件不错的情况下可能并不会发生什么事情，但是在网络情况差的时候就会变成画面卡住，然后再继续播放下一帧的情况。

## TCP

TCP 基本是和 UDP 反着来，建立连接断开连接都需要先需要进行握手。在传输数据的过程中，通过各种算法保证数据的可靠性，当然带来的问题就是相比 UDP 来说不那么的高效。TCP 连接建立完后都能发送和接收数据，所以 TCP 是一个全双工的协议。
对于 TCP 头部来说，以下几个字段是很重要的

-   Sequence number，这个序号保证了 TCP 传输的报文都是有序的，对端可以通过序号顺序的拼接报文
-   Acknowledgement Number，这个序号表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到
-   Window Size，窗口大小，表示还能接收多少字节的数据，用于流量控制
-   标识符
    -   URG=1：该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部。
    -   ACK=1：该字段为一表示确认号字段有效。此外，TCP 还规定在连接建立后传送的所有报文段都必须把 ACK 置为一。
    -   PSH=1：该字段为一表示接收端应该立即将数据 push 给应用层，而不是等到缓冲区满后再提交。
    -   RST=1：该字段为一表示当前 TCP 连接出现严重问题，可能需要重新建立 TCP 连接，也可以用于拒绝非法的报文段和拒绝连接请求。
    -   SYN=1：当 SYN=1，ACK=0 时，表示当前报文段是一个连接请求报文。当 SYN=1，ACK=1 时，表示当前报文段是一个同意建立连接的应答报文。
    -   FIN=1：该字段为一表示此报文段是一个释放连接的请求报文。

## 三次握手

-   第一次握手
    客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。
-   第二次握手

服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。

-   第三次握手

当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。

#### 为什么 TCP 建立连接需要三次握手

![image](/syn.png)

因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。

客户端发送了一个连接请求 A，但是因为网络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送一个连接请求 B。

此时请求顺利到达服务端，服务端应答完就建立了请求，然后接收数据后释放了连接。

假设这时候连接请求 A 在两端关闭后终于抵达了服务端，那么此时服务端会认为客户端又需要建立 TCP 连接，从而应答了该请求并进入 ESTABLISHED 状态。但是客户端其实是 CLOSED 的状态，那么就会导致服务端一直等待，造成资源的浪费。

#### 断开连接四次握手

-   第一次握手

若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。

-   第二次握手

B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。

-   第三次握手

B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。

-   第四次握手

A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（即两倍的 MSL`Maximum Segment Life`最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。

#### 为什么 A 要进入 TIME-WAIT 状态，等待 2MSL 时间后才进入 CLOSED 状态？

为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成 B 不能正常关闭。

## HTTPS 握手

#### TLS(transport layer security)安全传输层协议

#### SSL (Secure Sockets Layer)安全套接字协议

![image](/https.jpg)
![image](/accw.jpg)

1. 服务端将公钥发给证书颁发机构，向证书颁发机构申请证书。
2. 证书颁发机构有自己的密钥对，机构用自己的私钥加密服务端传来的 key1，并通过服务端网址等信息生成一个数字签名证书，证书同样经过机构的私钥加密。机构把证书发送给服务端。
3. 浏览器向服务端请求通信，服务端返回证书。【非对称加密 start】
4. 客户端收到证书以后，要做的第一件事情是验证证书的真伪。需要说明的是，各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥。所以客户端只需要知道是哪个机构颁布的证书，就可以从本地找到对应的机构公钥，解密出证书签名。浏览器按照同样的签名规则，自己也生成一个证书签名，如果两个签名一致，说明证书是有效的。
5. 验证成功后，浏览器再次利用机构公钥，解密出服务端的公钥 Key1。【非对称加密 end】
6. 浏览器生成自己的对称加密密钥 Key2，并且用服务端公钥 Key1 加密 Key2，发送给服务端
7. 服务端用自己的私钥解开加密，得到对称加密密钥 Key2。于是两人开始用 Key2 进行对称加密的通信。

:::tip 加密方式

1. 握手期间密钥非对称加密算法（RSA）
2. 握手后传输数据对称加密（AES/DES）
3. 证书信息摘要算法（SHA1/SHA256/MD5）
   :::

## HTTP2

> **起因:** 在 HTTP/1 中，为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是因为浏览器限制了同一个域名下的请求数量（Chrome 下一般是限制六个连接），当页面中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。

> **核心点:** 在之前的 HTTP 版本中，我们是通过文本的方式传输数据。在 HTTP/2 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。

> **优点：** HTTP/2 通过多路复用、二进制流、Header 压缩等等技术，极大地提高了性能，但是还是存在着问题的

> **缺点：** 因为 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。当这个连接中出现了丢包的情况，那就会导致 HTTP/2 的表现情况反倒不如 HTTP/1 了

> **解决方案：** QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议

#### Header 压缩

在 HTTP/1 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。

在 HTTP /2 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。

#### 多路复用

在 HTTP/2 中引入了多路复用的技术，这个技术可以只通过一个 TCP 连接就可以传输所有的请求数据。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度。

#### 服务端 Push

在 HTTP/2 中，服务端可以在客户端某个请求后，主动推送其他资源。

可以想象以下情况，某些资源客户端是一定会请求的，这时就可以采取服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下你也可以使用 prefetch 。

## 输入 URL 到页面渲染的整个流程

当你在浏览器中想访问 www.google.com 时，会进行一下操作：

-   操作系统会首先在本地缓存中查询 IP
-   没有的话会去系统配置的 DNS 服务器中查询
-   如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器
-   然后去该服务器查询 google 这个二级域名
-   接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP
    接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了。

在这一部分中，可以详细说下 TCP 的握手情况以及 TCP 的一些特性。

当 TCP 握手结束后就会进行 TLS 握手，然后就开始正式的传输数据。

在这一部分中，可以详细说下 TLS 的握手情况以及两种加密方式的内容。

数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件。

首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错。

浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件。

文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行。

如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP/2 协议的话会极大的提高多图的下载效率。

CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西

在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了。

这一部分就是渲染原理中讲解到的内容，可以详细的说明下这一过程。并且在下载文件时，也可以说下通过 HTTP/2 协议可以解决队头阻塞的问题。

## Post 和 Get 的区别？

首先先引入副作用和幂等的概念。

副作用指对服务器上的资源做改变，搜索是无副作用的，注册是副作用的。

幂等指发送 M 和 N 次请求（两者不相同且都大于 1），服务器上资源的状态一致，比如注册 10 个和 11 个帐号是不幂等的，对文章进行更改 10 次和 11 次是幂等的。因为前者是多了一个账号（资源），后者只是更新同一个资源。

在规范的应用场景上说，Get 多用于无副作用，幂等的场景，例如搜索关键字。Post 多用于副作用，不幂等的场景，例如注册。

在技术上说：

-   Get 请求能缓存(catch-control)，Post 不能
-   Post 相对 Get 安全一点点，因为 Get 请求都包含在 URL 里（当然你想写到 body 里也是可以的），且会被浏览器保存历史纪录。Post 不会，但是在抓包的情况下都是一样的。
-   URL 有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的
-   Post 支持更多的编码类型且不对数据类型限制

## 如果什么缓存策略都没设置，那么浏览器会怎么处理？

对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。

## 浏览器文件缓存位置？

浏览器可以在内存、硬盘中开辟一个空间用于保存请求资源副本。我们经常调试时在 DevTools Network 里看到 Memory Cache（內存缓存）和 Disk Cache（硬盘缓存），指的就是缓存所在的位置。请求一个资源时，会按照优先级（Service Worker -> Memory Cache -> Disk Cache -> Push Cache）依次查找缓存，如果命中则使用缓存，否则发起请求。这里先介绍 Memory Cache 和 Disk Cache。

-   200 from memory cache
    表示不访问服务器，直接从内存中读取缓存。因为缓存的资源保存在内存中，所以读取速度较快，但是关闭进程后，缓存资源也会随之销毁，一般来说，系统不会给内存分配较大的容量，因此内存缓存一般用于存储较小文件。同时内存缓存在有时效性要求的场景下也很有用（比如浏览器的隐私模式）。

-   200 from disk cache
    表示不访问服务器，直接从硬盘中读取缓存。与内存相比，硬盘的读取速度相对较慢，但硬盘缓存持续的时间更长，关闭进程之后，缓存的资源仍然存在。由于硬盘的容量较大，因此一般用于存储大文件。

-   200 from prefetch cache
    在 preload 或 prefetch 的资源加载时，两者也是均存储在 http cache，当资源加载完成后，如果资源是可以被缓存的，那么其被存储在 http cache 中等待后续使用；如果资源不可被缓存，那么其在被使用前均存储在 memory cache;

![Image from alias](/hm5o6ugws2.png)

## 重绘和回流？

重绘：当 DOM 树中的某些元素的属性需要更新，而这些属性只是影响元素的外观和风格，并不进行几何操作影响布局，比如 background-color，我们将这样的操作称为重绘。
回流：当渲染树中的一部分或者全部元素的规模尺寸、布局、隐藏显示等需要重新构建布局的操作，我们称为回流。
常见因此回流属性的方法：

1. JS 更改 DOM 元素（插入，删除、更新、移动、添加动画等，更改 DOM 颜色除外）
2. 元素尺寸改变-边距、填充、边控、宽高
3. 改变样式属性（颜色，透明度等除外）
4. 浏览器窗口尺寸改变
5. offsetWidth、offsetHeigh 和 getComputedStyle 之类的元素进行测量
6. 设置 style 属性的值
7. 修改网页默认字体
8. 内容变化，input 框中输入文字

## requestAnimationFrame

解决`setTimeout/setInterval`无法精准定位时间间隔
`requestAnimationFrame`的时间间隔是由系统控制而非 JS 控制

```javascript
var timer = requestAnimationFrame(function{
  console.log(1)
})
cancelAnimationFrame(timer)

// 判断浏览器是否兼容requestAnimationFrame
if(!window.requestAnimationFrame){
  requestAnimationFrame = function(fn){
    setTimeout(fn,17)
  };
}

// 实例:
<div id="test" style="width:300px;font-size:12px;height:16px;background:#290;">0%</div>
<script>
  const test = document.getElementById('test')
  // setTimeout实现
  test.onclick = function () {
    var timer = setTimeout(function fn() {
      if (parseInt(test.style.width) < 300) {
        test.style.width = parseInt(test.style.width) + 3 + 'px'
        test.innerHTML = parseInt(test.style.width) / 3 + '%'
        timer = setTimeout(fn, 17)
      } else {
        clearTimeout(timer)
      }
    }, 17)
  }
  // setInterval实现
  test.onclick = function () {
    var timer = setInterval(function () {
      if (parseInt(test.style.width) < 300) {
        test.style.width = parseInt(test.style.width) + 3 + 'px'
        test.innerHTML = parseInt(test.style.width) / 3 + '%'
      } else {
        clearInterval(timer)
      }
    }, 17)
  }
  // requestAnimationFrame实现
  test.onclick = function () {
    var timer = requestAnimationFrame(function fn() {
      if (parseInt(test.style.width) < 300) {
        test.style.width = parseInt(test.style.width) + 3 + 'px'
        test.innerHTML = parseInt(test.style.width) / 3 + '%'
        requestAnimationFrame(fn)
      } else {
        cancelAnimationFrame(timer)
      }
    })
  }
</script>

// equestAnimationFrame 不管理回调函数队列，
// 而滚动、触摸这类高触发频率事件的回调可能会在同一帧内触发多次。
// 所以正确使用 requestAnimationFrame 的姿势是，
// 在同一帧内可能调用多次 requestAnimationFrame 时，要管理回调函数，防止重复绘制动画。
const onScroll = e => {
    if (scheduledAnimationFrame) { return }

    scheduledAnimationFrame = true
    window.requestAnimationFrame(timestamp => {
        scheduledAnimationFrame = false
        animation(timestamp)
    })
}
window.addEventListener('scroll', onScroll)
```
